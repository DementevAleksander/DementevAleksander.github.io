{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/modules/cacl.js","webpack:///./src/js/modules/cards.js","webpack:///./src/js/modules/forms.js","webpack:///./src/js/modules/modal.js","webpack:///./src/js/modules/slider.js","webpack:///./src/js/modules/tabs.js","webpack:///./src/js/modules/timer.js","webpack:///./src/js/script.js","webpack:///./src/js/services/services.js"],"names":[],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA;AAAA;AACA;AACA;AACA;AACA,sCAAsC;AACtC,0CAA0C;AAC1C,KAAK,OAAO;AACZ;AACA;AACA;;AAEA,wCAAwC;AACxC,8CAA8C;AAC9C,KAAK,OAAO;AACZ;AACA;AACA;;AAEA;AACA;AACA,2DAA2D;AAC3D,wCAAwC;AACxC,mBAAmB;AACnB;AACA,+BAA+B;AAC/B,6GAA6G;AAC7G,SAAS,OAAO;AAChB,8GAA8G;AAC9G;AACA;AACA;;AAEA;AACA;AACA,6DAA6D;;AAE7D,kCAAkC;AAClC,+CAA+C;AAC/C,0EAA0E;AAC1E,gDAAgD;AAChD;AACA,oFAAoF;AACpF,gDAAgD;AAChD;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,0DAA0D;AAC1D,6DAA6D;;AAE7D,kCAAkC;AAClC,mDAAmD;AACnD,0DAA0D;AAC1D,iEAAiE;AACjE,wFAAwF;AACxF,iBAAiB;AACjB,sDAAsD;AACtD,6EAA6E;AAC7E;;AAEA,0CAA0C;AAC1C,uDAAuD;AACvD,iBAAiB;;AAEjB,oDAAoD;;AAEpD;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;AAEA;AACA,8C;AACA,uDAAuD;;AAEvD,+CAA+C;AAC/C,2CAA2C;AAC3C,qDAAqD;AACrD,aAAa;AACb,4CAA4C;AAC5C;AACA,8CAA8C;AAC9C;AACA,0CAA0C;AAC1C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEe,mEAAI,E;;;;;;;;;;;;AC1GnB;AAAA;AAAiD;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,iEAAiE;AACjE,+BAA+B;AAC/B,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA,4CAA4C;AAC5C,oDAAoD;AACpD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS,OAAO,SAAS;AACpD,kDAAkD,WAAW;AAC7D,gDAAgD,WAAW;AAC3D;AACA;AACA;AACA,0DAA0D,WAAW;AACrE;AACA;AACA;AACA,wCAAwC;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,oEAAK,E;;;;;;;;;;;;AC/EpB;AAAA;AAAA;AAA8C;AACA;;AAE9C;AACA;AACA,yDAAyD;AACzD;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL,iCAAiC;AACjC,gDAAgD;AAChD;AACA;AACA,8D;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,kEAAkE;;AAElE;AACA,gDAAgD,qDAAqD;;AAErG;AACA,gFAAgF;;AAEhF,YAAY,mEAAQ;AACpB;AACA,kCAAkC;AAClC;AACA,iDAAiD;AACjD,wCAAwC;AACxC;AACA;AACA,kDAAkD;AAClD,4BAA4B;AAC5B,8BAA8B,EAAE;AAChC,SAAS;AACT;;AAEA;AACA,uCAAuC;AACvC;;AAEA,8CAA8C;AAC9C,QAAQ,wDAAS,yBAAyB,8EAA8E;;AAExH;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA,6DAA6D;AAC7D;AACA;AACA,iCAAiC;AACjC;AACA;AACA,YAAY,yDAAU;AACtB,SAAS;AACT;;AAEA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;;AAEe,oEAAK,E;;;;;;;;;;;;ACpFpB;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;;AAEA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,sBAAsB;AACtB,oCAAoC;AACpC;;AAEA;;AAEA;AACA;AACA;AACA,+HAA+H;AAC/H;AACA;AACA;;AAEA;AACA;AACA,oFAAoF;AACpF,KAAK;;AAEL;AACA;AACA,8EAA8E;AAC9E;AACA;AACA,KAAK;;AAEL;AACA,iD;AACA,sEAAsE;AACtE;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,kHAAkH;AAClH;AACA,qEAAqE;AACrE;AACA;AACA;AACA;;AAEe,oEAAK,EAAC;AACD;;;;;;;;;;;;;AC3DpB;AAAA,iBAAiB,qFAAqF;AACtG,mBAAmB;AACnB,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;;AAEpD;AACA,6BAA6B;AAC7B,gCAAgC,cAAc,EAAE;AAChD,mCAAmC,WAAW;AAC9C,KAAK;AACL,0CAA0C;AAC1C;AACA;;AAEA,wDAAwD;AACxD,uCAAuC;AACvC,8CAA8C;;AAE9C,4CAA4C;;AAE5C,6BAA6B;AAC7B,kCAAkC;AAClC,KAAK;;AAEL,uCAAuC;;AAEvC;AACA;AACA,oBAAoB;AACpB,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,8BAA8B;;AAE9B,mBAAmB,mBAAmB,OAAO;AAC7C,iDAAiD;AACjD,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,kCAAkC;AAClC;AACA,+BAA+B;AAC/B,uBAAuB;AACvB;;AAEA;AACA;AACA;;AAEA,0CAA0C;AAC1C,uEAAuE;AACvE,uBAAuB;AACvB,SAAS;AACT,6CAA6C;AAC7C;;AAEA,qDAAqD,OAAO,KAAK;;AAEjE,0CAA0C;AAC1C,2BAA2B;AAC3B,SAAS;AACT,yBAAyB;AACzB;;AAEA,iCAAiC;AACjC,uCAAuC,WAAW,EAAE;AACpD,SAAS;AACT,8CAA8C;AAC9C;;AAEA,sDAAsD;AACtD,6CAA6C;AAC7C,KAAK;;AAEL;AACA;AACA,kEAAkE;AAClE,SAAS;AACT,6CAA6C;AAC7C;;AAEA,qDAAqD,OAAO;;AAE5D,8BAA8B;AAC9B,uCAAuC;AACvC,SAAS;AACT,yBAAyB;AACzB;;AAEA,iCAAiC;AACjC,uCAAuC,WAAW,EAAE;AACpD,SAAS;AACT,8CAA8C;AAC9C;;AAEA,sDAAsD;AACtD,6CAA6C;AAC7C,KAAK;;AAEL,yBAAyB;AACzB,8CAA8C;AAC9C,mEAAmE;;AAEnE,iCAAiC;AACjC,4DAA4D;;AAE5D,yDAAyD,OAAO,KAAK;;AAErE;AACA,2CAA2C,WAAW;AACtD,aAAa;AACb;AACA;;AAEA,0DAA0D;AAC1D,iDAAiD;AACjD,SAAS;AACT,KAAK;AACL;;AAEe,qEAAM,E;;;;;;;;;;;;ACzJrB;AAAA;AACA;AACA;AACA;AACA,gEAAgE;;AAEhE,gCAAgC;AAChC,qCAAqC;AACrC,uCAAuC;AACvC,kDAAkD;AAClD,SAAS;;AAET,8BAA8B;AAC9B,+CAA+C;AAC/C,SAAS;AACT;;AAEA,qCAAqC;AACrC;AACA,qDAAqD;AACrD,gDAAgD;AAChD,2CAA2C;AAC3C;;AAEA;AACA,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA,yEAAyE;AACzE,uCAAuC;AACvC,qCAAqC;AACrC,sCAAsC;AACtC,uCAAuC;AACvC;AACA,aAAa;AACb;AACA,KAAK;AACL;;AAEe,mEAAI,E;;;;;;;;;;;;AC5CnB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;;AAEpD;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,IAAI,EAAE;AAC7B,SAAS;AACT,uBAAuB;AACvB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2IAA2I;AACjK;AACA;AACA,gDAAgD;AAChD;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA,iCAAiC;AACjC,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,oEAAK,E;;;;;;;;;;;;ACnEpB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAa;;AAEqB;AACE;AACA;AACA;AACE;AACJ;AACE;AACM;;AAE1C;;AAEA;AACA,0CAA0C,gEAAS;;AAEnD,IAAI,6DAAI;AACR,IAAI,8DAAK;AACT,IAAI,8DAAK;AACT,IAAI,8DAAK;AACT,IAAI,6DAAI;AACR,IAAI,8DAAK;AACT,IAAI,+DAAM,EAAE;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;;;;;;;;;;;;;;;;AChCD;AAAA;AAAA;AAAA;AACA;AACA,uCAAuC;AACvC,gCAAgC;AAChC;AACA;AACA;AACA,kBAAkB;AAClB;AACA,SAAS;AACT;AACA,KAAK,E;AACL;AACA,4BAA4B;AAC5B;AACA;;AAEA,oCAAoC;AACpC;AACA;AACA,2CAA2C,IAAI,YAAY,WAAW;AACtE;AACA,4B;AACA;;AAEkB","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/js/script.js\");\n","function calc() {\r\n    // Калькулятор калорий.\r\n    const result = document.querySelector('.calculating__result span');\r\n    let sex, height, weight, age, ratio;\r\n    if (localStorage.getItem('sex')) { //Если в локальном хранилище есть ключ sex\r\n        sex = localStorage.getItem('sex'); //то в переменную sex записываем значение ключа sex из локального хранилища.\r\n    } else { //Иначе устанавливаем значения по умолчанию.\r\n        sex = 'female';\r\n        localStorage.setItem('sex', 'female');\r\n    }\r\n\r\n    if (localStorage.getItem('ratio')) { //Если в локальном хранилище есть ключ ratio\r\n        ratio = localStorage.getItem('ratio'); //то в переменную ratio записываем значение ключа ratio из локального хранилища.\r\n    } else { //Иначе устанавливаем значения по умолчанию.\r\n        ratio = 1.375;\r\n        localStorage.setItem('ratio', 1.375);\r\n    }\r\n\r\n    //Функция подсчёта по формуле вычисления каллорий\r\n    function calcTotal() {\r\n        if (!sex || !height || !weight || !age || !ratio) { //Если не заполнено поля каким-нибудь значением\r\n            result.textContent = '____'; // То выводим сообщение.\r\n            return; //Это необходимо, чтобы прервать функцию.\r\n        }\r\n        if (sex === 'female') { //Если пол женский, то считаем по формуле.\r\n            result.textContent = Math.round((447.6 + (9.2 * weight) + (3.1 * height) - (4.3 * age)) * ratio); //BMR = 447.6 + (9.2 x вес, кг) + (3.1 х рост, cм) – (4.3 х возраст, лет). И результат умножаем на коэффициент активности ratio.\r\n        } else { //Иначе (мужской).\r\n            result.textContent = Math.round((88.36 + (13.4 * weight) + (4.8 * height) - (5.7 * age)) * ratio); //BMR = 88.36 + (13.4 x вес, кг) + (4.8 х рост, см) – (5.7 х возраст, лет). И результат умножаем на коэффициент активности ratio.\r\n        }\r\n    }\r\n    calcTotal();\r\n\r\n    //Устанавливаем классы активности, в зависимаости от сохранённых значений в localStorage.\r\n    function initLocalSettings(selector, activeClass) {\r\n        const elements = document.querySelectorAll(selector); //Элементы с которыми будем работать.\r\n\r\n        elements.forEach(elem => { //Перебираем элементы.\r\n            elem.classList.remove(activeClass); //Чистим класс актвивности. \r\n            if (elem.getAttribute('id') === localStorage.getItem('sex')) { //Если кнопка с id совпадает с значением из localStorage (с ключом sex).\r\n                elem.classList.add(activeClass); //Устанавливаем класс активности на той кнопке, которая нажата.\r\n            }\r\n            if (elem.getAttribute('data-ratio') === localStorage.getItem('ratio')) { //Если кнопка с атрибутом data-ratio совпадает с значением из localStorage (с ключом ratio).\r\n                elem.classList.add(activeClass); //Устанавливаем класс активности на той кнопке, которая нажата.\r\n            }\r\n        });\r\n    }\r\n    initLocalSettings('#gender div', 'calculating__choose-item_active');\r\n    initLocalSettings('.calculating__choose_big div', 'calculating__choose-item_active');\r\n\r\n    //Получаем данные с элементов (статический контент).\r\n    function getStaticInformation(selector, activeClass) { //функция будет применяться на нескольких элементах, потому требуется parentSelector. Так же требуется класс активности activeClass для окрашивания кнопок, которые были нажаты.\r\n        const elements = document.querySelectorAll(selector); // Получаем все div внутри выбранного элемента.\r\n\r\n        elements.forEach(elem => { //Перебираем все элементы. Используем делегирование событий.\r\n            elem.addEventListener('click', (e) => { //Отслеживаем клики по родительскому элементу.\r\n                if (e.target.getAttribute('data-ratio')) { //Если атрибут data-ratio присутсвует у объекта события. Это нужно, так как не у всех кнопок есть атрибут data-ratio.\r\n                    ratio = +e.target.getAttribute('data-ratio'); //устанавливаем значение ratio в значение, которое взяли у e.target, то есть в значение дата атрибута data-ratio.\r\n                    localStorage.setItem('ratio', +e.target.getAttribute('data-ratio')); //Устанавливаем в параметр ratio со тем значением, которое вёл пользователь для поля с атрибутом data-ratio.\r\n                } else {\r\n                    sex = e.target.getAttribute('id'); //Если у элемента нет атрибута data-ratio, то этот впеременную \"пол\" записываем значение id элемента в который щёлкнули.\r\n                    localStorage.setItem('sex', e.target.getAttribute('id')); //Устанавливаем в параметр sex с тем значением, которое вёл пользователь для поля с id.\r\n                }\r\n    \r\n                elements.forEach(elem => { //перебираем все элементы.\r\n                    elem.classList.remove(activeClass); // убираем класс активности.\r\n                });\r\n    \r\n                e.target.classList.add(activeClass); //Добавляем класс активности.\r\n    \r\n                calcTotal();\r\n            });\r\n        });\r\n    }\r\n    getStaticInformation('#gender div', 'calculating__choose-item_active');\r\n    getStaticInformation('.calculating__choose_big div', 'calculating__choose-item_active');\r\n\r\n    //Получаем данные с элементов (динамический контент, который вводит пользователь). \r\n    function getDynamicInformation(selector) { \r\n        const input = document.querySelector(selector); //Получаем данные с поля, которые заполнил пользователь.\r\n\r\n        input.addEventListener('input', () => { //отслеживаем, когда пользователь вводит данные.\r\n            if (input.value.match(/\\D/g)) { //Если в поле введено что-то кроме чисел.\r\n                input.style.border = \"1px solid red\"; //Подсвечиваем поле красным цветом.\r\n            } else {\r\n                input.style.border = 'none'; //Если введено число, то не подсвечиваем поле.\r\n            }\r\n            switch(input.getAttribute('id')) { //Проверяем есть ли у элемента атрибут id.\r\n                case \"height\":\r\n                    height = +input.value; //Записываем значение value, которое ввёл пользователь.\r\n                    break; //Останавиваем кейс.\r\n                case \"weight\":\r\n                    weight = +input.value;\r\n                    break;\r\n                case \"age\":\r\n                    age = +input.value;\r\n                    break;\r\n            }\r\n\r\n            calcTotal();\r\n        });\r\n    }\r\n    getDynamicInformation('#height');\r\n    getDynamicInformation('#weight');\r\n    getDynamicInformation('#age');\r\n}\r\n\r\nexport default calc;","import {getResource} from '../services/services';\r\n\r\nfunction cards() {\r\n    //------------------------- Классы стандарт ES6. Карточки на сайте. ----------------------//\r\n    class MenuCard {\r\n        constructor (src, alt, title, descr, price, parentSelector, ...classes) {\r\n            this.src = src;\r\n            this.alt = alt;\r\n            this.title = title;\r\n            this.descr = descr;\r\n            this.price = price;\r\n            this.classes = classes; //массив\r\n            this.parent = document.querySelector(parentSelector); //получаем один элемент. \r\n            this.transfer = 72; //курс валют.\r\n            this.changeToRUB(); //Конвертация валюты.\r\n        }\r\n        //Создаём дополнитеьный метод, который будет заниматься конвертацией валют.\r\n        changeToRUB () {\r\n            this.price = this.price * this.transfer;\r\n        }\r\n        // Ещё один метод для формирования вёрстки. В данном случае render классическое название.\r\n        render (){\r\n            const element = document.createElement('div'); //создаём элемент в JS <div></div>\r\n            if (this.classes.length === 0) {\r\n                this.element = 'menu__item';//перезаписываем массив.\r\n                element.classList.add(this.element); //ставим дефолтный класс\r\n            } else {\r\n            //Обрабатываем массив ...classes, проходимся по каждому элементу, вытаскиваем название класса и подсоединяем его к div.\r\n            this.classes.forEach(className => element.classList.add(className));\r\n            }\r\n            element.innerHTML = // обращаемся к элементу <div></div>. Через innerHTML динамически создаём структуру, указывая меняющиеся элементы.\r\n            `\r\n                <img src=${this.src} alt=${this.alt}>\r\n                <h3 class=\"menu__item-subtitle\">${this.title}</h3>\r\n                <div class=\"menu__item-descr\">${this.descr}</div>\r\n                <div class=\"menu__item-divider\"></div>\r\n                <div class=\"menu__item-price\">\r\n                    <div class=\"menu__item-cost\">Цена:</div>\r\n                    <div class=\"menu__item-total\"><span>${this.price}</span> руб./день</div>\r\n                </div>\r\n            `;\r\n            //Нужно указать, куда мы будем помещать все эти карточки. Каждый раз, когда будет вызываться MenuCard это родитель может быть абсолютно разным. Для этого создаём в MenuCard дополнительный аргумент parentSelector, то есть передаём именно селектор parentSelector. Соответственно нужно получить элемент со страницы, куда мы будем помещать этот элемент.\r\n            this.parent.append(element); //Помещаем новый элемент внутрь элемента. Метод ParentNode.append добавляет набор объектов Node или DOMString в конец (после последнего потомка) ParentNode. DOMString объекты добавляются как Text.\r\n        }\r\n    }\r\n    \r\n    new MenuCard(\r\n        \"img/tabs/vegy.jpg\", //Рекуомндуется/чаще всего используются двойные кавычки.\r\n        \"vegy\",\r\n        'Меню \"Фитнес\"', //Если двойные кавычки есть в тексте, тогда используем одинарные кавычки.\r\n        'Меню \"Фитнес\" - это новый подход к приготовлению блюд: больше свежих овощей и фруктов. Продукт активных и здоровых людей. Это абсолютно новый продукт с оптимальной ценой и высоким качеством!',\r\n        9, //долларов. Число трансформируется через метод changeToRUB ().\r\n        '.menu .container',\r\n        'menu__item',\r\n        'big'\r\n    ).render();\r\n    // Создаём ещё карточки. Пока что копируем. Но нужно уходить от копипаста и оптимизмровать код.\r\n    new MenuCard(\r\n        \"img/tabs/elite.jpg\", //Рекуомндуется/чаще всего используются двойные кавычки.\r\n        \"elite\",\r\n        'Меню “Премиум”', //Если двойные кавычки есть в тексте, тогда используем одинарные кавычки.\r\n        'В меню “Премиум” мы используем не только красивый дизайн упаковки, но и качественное исполнение блюд. Красная рыба, морепродукты, фрукты - ресторанное меню без похода в ресторан!',\r\n        14, //долларов. Число трансформируется через метод changeToRUB ().\r\n        '.menu .container',\r\n        'menu__item',\r\n        'big'\r\n    ).render();\r\n    new MenuCard(\r\n        \"img/tabs/post.jpg\", //Рекуомндуется/чаще всего используются двойные кавычки.\r\n        \"post\",\r\n        'Меню \"Постное\"', //Если двойные кавычки есть в тексте, тогда используем одинарные кавычки.\r\n        'Меню “Постное” - это тщательный подбор ингредиентов: полное отсутствие продуктов животного происхождения, молоко из миндаля, овса, кокоса или гречки, правильное количество белков за счет тофу и импортных вегетарианских стейков.',\r\n        21, //долларов. Число трансформируется через метод changeToRUB ().\r\n        '.menu .container',\r\n        //'menu__item',\r\n        //'big'\r\n    ).render();\r\n}\r\n\r\nexport default cards;","import {closeModal, openModal} from './modal';\r\nimport {postData} from '../services/services';\r\n\r\nfunction forms(formSelector, modalTimerId) {\r\n    //---------------------- Скрипт отправки данных на сервер. -------------------------//\r\n    const form = document.querySelectorAll(formSelector);    //Получаем все формы по тегу form\r\n    //Пишем функцию, которая отвечает за постинг данных.\r\n    const message = { // Сообщения по итогам обращения к серверу.\r\n        loading: 'img/form/spinner.svg', //Исползуем спиннер.\r\n        success: 'Спасибо! Мы свяжемся с вами в ближайшее время!',\r\n        failure: 'Что-то пошло не так! Позвоните нам для оформления заказа!'\r\n    };\r\n\r\n    //Берём все формы и под каждую из них подвязываем bindPostData().\r\n    form.forEach(item => {\r\n        bindPostData(item);\r\n    });\r\n\r\n    function bindPostData(form) { // bindPostData - привязка постинга, то есть привязать какой-то постинг данных.\r\n        form.addEventListener('submit', (e) => { //Отслеживаем отправку данных. Нажатие кнопки.\r\n            e.preventDefault();\r\n            //Динамически создаём новый блок для сообщения, который добавляется к форме.\r\n            let statusMessage = document.createElement('img'); \r\n            statusMessage.src = message.loading; //спиннер 'img/form/spinner.svg' вместо текста div\r\n            statusMessage.style.cssText = //В img записали стили. Правильнее помещать в CSS.\r\n            ` \r\n                display: block;\r\n                margin: 0 auto;\r\n            `;\r\n            form.insertAdjacentElement('afterend', statusMessage); //'afterend' - Куда вставляем (после формы), statusMessage - что вставляем.\r\n\r\n            //Отправляем данные на сервер.\r\n            const formData = new FormData(form); //собираем данные из document.querySelector('form');. Создаём объект, в котором будут введённые данные.\r\n            \r\n            //Трансформируем formData в JSON формат.\r\n            const json = JSON.stringify(Object.fromEntries(formData.entries())); // .entries() - получаем данные с формы в формате массива. .fromEntries() - Превращаем массив в объект. Затем объект превращаем в JSON-формат.\r\n\r\n            postData('https://proper-food.dementev-aleksandr.ru/db.json', json)\r\n            .then(data => {\r\n                console.log(data); //При положительном результате выводим объект с данными в консоль.\r\n                console.log(message.success);\r\n                showThanksModal(message.success); //Запускаем функцию с сообщением, что всё ОК. Показывается модальное окно и через 4 чекунды оно закрывается, вместе с тексом и возвращением изначального контента, который там был.\r\n                statusMessage.remove();}) //Удаляем спиннер.\r\n            .catch(() => {\r\n                console.log(message.failure);\r\n                showThanksModal(message.failure);}) //При отрицательном запросе к БД выдаём сообщение об ошибке.\r\n            .finally(() => { //При любом исходе.\r\n                form.reset();}); //Очищаем форму.\r\n        });\r\n    }\r\n\r\n    //---------------------- Улучшаем форму отправки данных на сервер -------------------------//\r\n    function showThanksModal(message) { //message - соообщение, которое будет отправляться пользователю.\r\n        const prevModalDialog = document.querySelector('.modal__dialog');\r\n\r\n        prevModalDialog.classList.add('hide'); //Скрываем .modal__dialog добавлением класса .hide.\r\n        openModal('.modal', modalTimerId); //Функция описана выше. Открывает модальное окно modal.classList.add('show'); modal.classList.remove('hide');\r\n\r\n        const thanksModal = document.createElement('div');\r\n        thanksModal.classList.add('modal__dialog'); //Для div добавляем класс modal__dialog.\r\n        thanksModal.innerHTML = //формируем вёрстку.\r\n        `\r\n            <div class=\"modal__content\">\r\n                <div class=\"modal__close\" data-close>×</div>\r\n                <div class=\"modal__title\">${message}</div>\r\n            </div>\r\n        `;\r\n        document.querySelector('.modal').append(thanksModal); //получаем модальное окно и аппендим туда наш блок.\r\n        //Если пользователь захочет снова открыть модальное окно, тогда всё должно возвращаться на свои места. Новый блок исчезал, а старый возвращался на место.\r\n        setTimeout(() => {\r\n            thanksModal.remove(); //через 4 секунды удаляем div с классом modal__dialog.\r\n            prevModalDialog.classList.add('show');\r\n            prevModalDialog.classList.remove('hide');\r\n            closeModal('.modal');\r\n        }, 4000);\r\n    }\r\n\r\n    //Обращаемся к локальной БД.\r\n    fetch('https://proper-food.dementev-aleksandr.ru/db.json')\r\n        .then(data => data.json()) //Берём объект из сервера и превращаем его в js объект.\r\n        .then(res => console.log(res)); //выведем результат в консоль.\r\n    //Результат. Получены данные для получения карточек меню. Меню - массив, который содержит отдельные объекты. Получаем массив данных. Если бы обращались на прямую к файлу fetch('db.json'), то получали бы объект, так как там объекты\r\n}\r\n\r\nexport default forms;","function closeModal(modalSelector) {\r\n    const modal = document.querySelector(modalSelector);\r\n    modal.classList.add('hide');\r\n    modal.classList.remove('show');\r\n    document.body.style.overflow = ''; //Возвращаем прокрутку сайта.\r\n}\r\n\r\nfunction openModal(modalSelector, modalTimerId) {\r\n    const modal = document.querySelector(modalSelector);\r\n    modal.classList.add('show');\r\n    modal.classList.remove('hide');\r\n    document.body.style.overflow = 'hidden'; //Убираем прокрутку сайта.\r\n    console.log(modalTimerId);\r\n    if(modalTimerId) { // Если modalTimmerId существует, то только тогда он будет запускаться.\r\n        clearInterval(modalTimerId); //Если пользователь сам вызвал модальное окно, то оно не будет открываться повторно через заданный промежуток времени.\r\n    }\r\n    \r\n}\r\n\r\nfunction modal(triggerSelector, modalSelector, modalTimerId) {\r\n    //------------------------------ Работа с модальным окном -------------------------//\r\n    // В HTML для модального окна прописывает атрибут data-modal. Пример, <button data-modal class=\"btn btn_dark\">Связаться с нами</button>.\r\n    // Для закрытия модального окна прописываем дата атрибут data-close. Например, <div data-close class=\"modal__close\">&times;</div>.\r\n    //Создаём две функции. 1 - отвечает за открытие модального окна, 2 - за закрытие.\r\n    const modalTridder = document.querySelectorAll(triggerSelector),\r\n          modal = document.querySelector(modalSelector);\r\n\r\n    modalTridder.forEach(btn => {\r\n        //При нажатии на кнопку button Связаться с нами, открываем модальное окно.\r\n        btn.addEventListener('click', () => openModal(modalSelector, modalTimerId)); //обарачиваем openModal() в стрелочную функцию () =>, чтобы она сразу не открывалась на странице.\r\n    });\r\n\r\n    //Закрываем моддальное окно по нажатию не только на крестик, но и на подложку.\r\n    modal.addEventListener('click', (e) => {\r\n        if (e.target === modal || e.target.getAttribute('data-close') == '') { //Свойство target интерфейса Event является ссылкой на объект, который был инициатором события или e.target это крестик модального окна, если он присутсвует, то мы будем закрывать модальное окно.\r\n            closeModal(modalSelector);\r\n        }\r\n    });\r\n\r\n    //Закрываем модальное окно по нажатию Esc на клавиатуре.\r\n    document.addEventListener('keydown', (e) => { \r\n        if (e.code === \"Escape\" && modal.classList.contains('show')) { //Закрываем модальное окно по нажатию Esc на клавиатуре только тогда, когда модальное окно открыто.\r\n            closeModal(modalSelector);\r\n        }\r\n    });\r\n\r\n    //Вызываем модальное окно когда страница долистана до конца.\r\n    //Чтобы определить, что пользователь долистал до конца делаем математическую формулу - берём свойство, которое отвечает за прокрутку сверху, затем берём свойство, которое отображает высоту пользовательского окна (видимой части) и будем её сравнивать со scrollHeight,\r\n    //то есть с полной прокруткой и с полным контентом, который есть и если два этих выражения будут совпадать, то значит, что пользователь долистал до конца.\r\n    function showModuleByScroll() {\r\n        if (window.pageYOffset + document.documentElement.clientHeight >= document.documentElement.scrollHeight) { //если пользователь долистал до конца\r\n            openModal(modalSelector, modalTimerId);\r\n            window.removeEventListener('scroll', showModuleByScroll); // Удаляем обработчик события. Когда пользователь долистывает до конца страницы модальное окно открывается только один раз. \r\n        }\r\n    }\r\n    window.addEventListener('scroll', showModuleByScroll);\r\n}\r\n\r\nexport default modal;\r\nexport {closeModal};\r\nexport {openModal};","function slider({conteiner, slide, nextArrow, prevArrow, totalCounter, currentCounter, wrapper, field}) {\r\n    let offset = 0; //Определяет текущий отступ слайда.\r\n    let slideIndex = 1; //Определяет текущее положение слайда. Изначально №1.\r\n\r\n    const slides = document.querySelectorAll(conteiner), //Родительский элемент каждого отдельного слайда.\r\n        slider = document.querySelector(slide), //Родительский элемен всего слайдера, включая кнопки навигации.\r\n        prev = document.querySelector(prevArrow), //Стрелка влево.\r\n        next = document.querySelector(nextArrow), //Стрелка вправо.\r\n        total = document.querySelector(totalCounter), //Номер слайда \"Всего\" 04/#total.\r\n        current = document.querySelector(currentCounter), //Номер текущего слайда #current/04.\r\n        slidesWrapper = document.querySelector(wrapper), // Обёртка для слайдов (для тега с классом .offer__slider-inner). Родительский элемент всех слайдов.\r\n        width = window.getComputedStyle(slidesWrapper).width, //Метод Window.getComputedStyle() возвращает объект, содержащий значения всех CSS-свойств элемента, полученных после применения всех активных таблиц стилей, и завершения базовых вычислений значений, которые они могут содержать. Получаем ширину width окошка .offer__slider-wrapper, через которое отображаются слайды.\r\n        slidesField = document.querySelector(field); // Обёртка для слайдов (для тега с классом .offer__slide)\r\n\r\n    //Определяем общее количество слайдов.\r\n    if (slides.length < 10) { //Если количество элементов .offer__slide меньше 10.\r\n        total.textContent = `0${slides.length}`; //Возвращаем количество слайдов с добавлением 0 и записываем в тег с #total. Cвойство length объекта, который является экземпляром типа Array , устанавливает или возвращает число элементов этого массива. \r\n        current.textContent =  `0${slideIndex}`;\r\n    } else {\r\n        total.textContent = slides.length; // Возвращаем количество слайдов, не подставляя 0 вначале и записываем в тег с #total.\r\n        current.textContent =  slideIndex;\r\n    }\r\n\r\n    slidesField.style.width = 100 * slides.length + '%'; //Устанавливаем ширину блока .offer__slider-inner в 100%*4слайда = 400%. \r\n    slidesField.style.display = 'flex'; //Устанавливаем все слайды в одну строку.\r\n    slidesField.style.transition = '0.5s all'; //Задержка в 0.5s.\r\n\r\n    slidesWrapper.style.overflow = 'hidden'; //Ограничиваем показ внутри .offer__slider-wrapper.\r\n\r\n    slides.forEach(slide => { //перебираем все .offer__slide (Родительский элемент каждого отдельного слайда).\r\n        slide.style.width = width; //для каждого .offer__slide устанавиваем ширину в window.getComputedStyle(slidesWrapper).width.\r\n    });\r\n\r\n    slider.style.position = 'relative'; //Устанавливаем для .offer__slider position = 'relative'.\r\n\r\n    //Создаём большую обёртку для всех слайдов и стилизуем её.\r\n    const indicators = document.createElement('ol'), //Блок с точками для слайдов.\r\n          dots = []; //Истинный массив, в котором можем использовать push.\r\n    indicators.classList.add('carousel-indicators'); //Класс для блока с точками для слайдов.\r\n    indicators.style.cssText = `\r\n        position: absolute;\r\n        right: 0;\r\n        bottom: 0;\r\n        left: 0;\r\n        z-index: 15;\r\n        display: flex;\r\n        justify-content: center;\r\n        margin-right: 15%;\r\n        margin-left: 15%;\r\n        list-style: none;\r\n    `; // Добавляем стили для класса carousel-indicators\r\n    slider.append(indicators); //Помещаем .carousel-indicators внутрь .offer__slider.\r\n\r\n    for (let i = 0; i < slides.length; i++) { //Цикл закончится тогда, когда закончаться сллайды.\r\n        const dot = document.createElement('li'); //Создаём точки (li).\r\n        dot.setAttribute('data-slide-to', i + 1); //Индикатор соответвия, например первая точка ведёт к первому слайду. .setAttribute() - Добавляет новый атрибут или изменяет значение существующего атрибута у выбранного элемента. Каждой токе устанавливаем атрибут data-slide-to, и устанавливаем нумеруацию, начиная с 1.\r\n        dot.style.cssText = `\r\n            box-sizing: content-box;\r\n            flex: 0 1 auto;\r\n            width: 30px;\r\n            height: 6px;\r\n            margin-right: 3px;\r\n            margin-left: 3px;\r\n            cursor: pointer;\r\n            background-color: #fff;\r\n            background-clip: padding-box;\r\n            border-top: 10px solid transparent;\r\n            border-bottom: 10px solid transparent;\r\n            opacity: .5;\r\n            transition: opacity .6s ease;\r\n        `;\r\n        if (i == 0) { //Если итерация первая, то \r\n            dot.style.opacity = 1; //Обращаемся к li и добавляем ему стиль opacity = 1.\r\n        }\r\n        indicators.append(dot); //Добавляем li в ol\r\n        dots.push(dot); //Помещаем li в массив dots. В итоге получаем массив с точками.\r\n    }\r\n\r\n    function deleteNotDigits(str) {\r\n        return +str.replace(/\\D/g, '');\r\n    }\r\n\r\n    next.addEventListener('click', () => { //Нажимаем на кнопку \"Вперёд\".\r\n        if (offset == (deleteNotDigits(width) * (slides.length - 1))) { //+width.replace(/\\D/g, '')- все не числа, которые находятся внутри строки удаляем, полученное число умножаем на 4слайда (slides.length - 1).\r\n            offset = 0; //Возвращаемся в начало.\r\n        } else {\r\n            offset += deleteNotDigits(width); //Добавляем смещение +650px. Записываем значение в offset. \r\n        }\r\n\r\n        slidesField.style.transform = `translateX(-${offset}px)`; // Обращаемся к .offer__slider-inner. Трансформируем элемент по оси x. Используем знак \"-\" для сдвига в минус. \r\n\r\n        if (slideIndex == slides.length) { //Если текущий слайд равен количеству слайдов на странице всего, то\r\n            slideIndex = 1; //Установить текущий слайд в 1.\r\n        } else {\r\n            slideIndex++; //Иначе добавляем к текущему слайду 1.\r\n        }\r\n\r\n        if (slides.length < 10) { //Если количество слайдов меньше 10\r\n            current.textContent =  `0${slideIndex}`; //Установить текущий слайд в 0+номер текущего слайда в тегах html.\r\n        } else {\r\n            current.textContent =  slideIndex; // Иначе указываем просто текущий слайд в тегах html.\r\n        }\r\n\r\n        dots.forEach(dot => dot.style.opacity = \".5\"); //Перебираем массив dots. Каждой точке устанавливаем стили в opacity = \".5\".\r\n        dots[slideIndex-1].style.opacity = 1; //Устанавливаем для dots номер текущего слайда - 1 в opacity = 1.\r\n    });\r\n\r\n    prev.addEventListener('click', () => {\r\n        if (offset == 0) {\r\n            offset = deleteNotDigits(width) * (slides.length - 1); //Устанавливаем в 1950px.\r\n        } else {\r\n            offset -= deleteNotDigits(width); // offset = offset - +width.slice(0, width.length - 2).\r\n        }\r\n\r\n        slidesField.style.transform = `translateX(-${offset}px)`;\r\n\r\n        if (slideIndex == 1) { //Если текущий слайд  равен 1, то\r\n            slideIndex = slides.length; //Устанавливаем текущий слайд в количество слайдов \"Всего\".\r\n        } else {\r\n            slideIndex--; //Иначе уменьшаем текущий номер слайда на 1.\r\n        }\r\n\r\n        if (slides.length < 10) { //Если количество слайдов меньше 10, то\r\n            current.textContent =  `0${slideIndex}`; //Указываем в тегах 0+текущйи слайд html.\r\n        } else {\r\n            current.textContent =  slideIndex; //Иначе указываем в тегах номер текущего слайда html.\r\n        }\r\n\r\n        dots.forEach(dot => dot.style.opacity = \".5\"); //Перебираем массив dots. Каждой точке устанавливаем стили в opacity = \".5\".\r\n        dots[slideIndex-1].style.opacity = 1; //Устанавливаем для dots номер текущего слайда - 1 в opacity = 1.\r\n    });\r\n\r\n    dots.forEach(dot => { //Для массива dots, в котором содержатся li.\r\n        dot.addEventListener('click', (e) => { //На каждую точку навешиваем обработчик события клика.\r\n            const slideTo = e.target.getAttribute('data-slide-to'); //Используем объект события. Получаем атрибут data-slide-to.\r\n\r\n            slideIndex = slideTo; //Номер слайда устанавливаем в data-slide-to, то есть кликнули на data-slide-to=4, текущий слайд установился в 1.\r\n            offset = deleteNotDigits(width) * (slideTo - 1); //Берём общую ширину слайда * на номер li (data-slide-to).\r\n\r\n            slidesField.style.transform = `translateX(-${offset}px)`; //Устанавливаем смещение для слайдера.\r\n\r\n            if (slides.length < 10) {\r\n                current.textContent =  `0${slideIndex}`;\r\n            } else {\r\n                current.textContent =  slideIndex;\r\n            }\r\n\r\n            dots.forEach(dot => dot.style.opacity = \".5\"); //Перебираем массив dots. Каждой точке устанавливаем стили в opacity = \".5\".\r\n            dots[slideIndex-1].style.opacity = 1; //Устанавливаем для dots номер текущего слайда - 1 в opacity = 1.\r\n        });\r\n    });\r\n}\r\n\r\nexport default slider;","function tabs(tabsSelector, tabsContentSelector, tabsParentSelector, activeClass) {\r\n    //--------------------- Переключение контента по нажатию на вкладку --------------//\r\n    let tabs = document.querySelectorAll(tabsSelector), //Получаем все вкладки.\r\n        tabsContent = document.querySelectorAll(tabsContentSelector), //Получаем весь контентент для вкладок.\r\n        tabsParent = document.querySelector(tabsParentSelector); //Получаем родитеьский элемент вкладок.\r\n    \r\n    function hideTypeContent() { //Создаём функуию, которая скрывает контент вкладки.\r\n        tabsContent.forEach(item => { // перебираем псевдомасив с .tabcontent\r\n            item.classList.add('hide'); //добавляем класс hide, который скрывает контент.\r\n            item.classList.remove('show', 'fade'); //добавляем класс show, который показывает контент,убираем анимацию.\r\n        });\r\n        \r\n        tabs.forEach(item => { //Убираем класс активности. Перебираем псевдомасив с .tabheader__item\r\n            item.classList.remove(activeClass); //удаляем ...._active найденный в .tabheader__item.\r\n        });\r\n    }\r\n\r\n    function showTypeContent(i = 0) { //Создаём функцуию, которая показывает контент вкладки.\r\n        // По умолчанию выводится первый элемент.\r\n        tabsContent[i].classList.add('show', 'fade'); //добавляем класс hide, который скрывает контент + анимация.\r\n        tabsContent[i].classList.remove('hide'); //добавляем класс show, который показывает контент.\r\n        tabs[i].classList.add(activeClass); //добавляем ...._active найденный в .tabheader__item.\r\n    }\r\n\r\n    hideTypeContent();\r\n    showTypeContent(); //по умолчанию показываем контент первой вкладки.\r\n\r\n    // Когда кликнули в пункт меню определяем его № в списке всех табов и по этому № вызываем функцию showTypeContent(),\r\n    // то есть показываем контент и делается это перебором. Перебераем все табы, и сравниваем,\r\n    // если элемент, который находится в псевдомассиве .tabheader__item совпадает с тем элементом,\r\n    // который кликнул пользователь, тогда мы берём его номер и показываем на странице.\r\n    tabsParent.addEventListener('click', (event) => { //Нажимаем на .tabheader\r\n        const target = event.target;\r\n        if (target && target.classList.contains(tabsSelector.slice(1))) { //кликнули точно на вкладку.\r\n            tabs.forEach((item, i) => { //перебираем массив с вкладками .tabheader__item.\r\n                if (target == item) { // если .tabheader__item совпадаем с элементом в .forEach, то есть item.\r\n                    hideTypeContent(); //то скрываем весь контент.\r\n                    showTypeContent(i); //показываем тот порядковый элемент i в который кликнули.\r\n                }\r\n            });\r\n        }\r\n    });\r\n}\r\n\r\nexport default tabs;","function timer(id, deadline) {\r\n    //------------------------------------- Таймер на сайте -------------------------------//\r\n    // Timer\r\n    // Делаем функцию, которая определяет разницу между деадлайном и текущим временем.\r\n    function getTimeRemaining(endtime) {\r\n        const t = Date.parse(endtime) - Date.parse(new Date()), //получаем разницу в милисекундах между конечной датой и текущей датой.\r\n              //Превращаем количество милисекунд в формат Дни/Часы/Минуты/Секунды.\r\n              days = Math.floor(t / (1000 * 60 * 60 * 24)),\r\n              //Подсчитать количество дней, которые будут отображаться в таймере. Делим количество милисекунд на количество милисекунд, которые находятся в одном дне.\r\n              // Количество милисекунд умножаем на 60, получаем милисекунд в одной минуте, дальше снова на 60, получаем милисекунд в часе, умножаем на 24, получаем количество милисекунд в сутках.\r\n              // Делим оставшиеся милисекунды до deadline на количество милисекунд в сутках, полуаем количество суток.\r\n              // Math.floor() - округление до целого числа.\r\n              hours = Math.floor((t / (1000 * 60 * 60) % 24)),\r\n              // (1000 * 60 * 60) - получаем количество милисекунд в часе, t / (1000 * 60 * 60) - получаем оставшееся количество часов, % 24 - делим количество часов на 24 и получаем остаток, таким образом мы получаем число, которое не хватает до полных суток.\r\n              //Например, при делении t / (1000 * 60 * 60) получилось 50 часов. 50 делим на 24, получаем два дня (48), и в остатке два часа.\r\n              minutes = Math.floor((t / 1000 / 60) % 60), //Минуты\r\n              seconds = Math.floor((t / 1000) % 60); //Секунды\r\n\r\n              //Чтобы вывести переменные наружу, используем return\r\n              return { //Возвращаем объект и возвращаем из функции\r\n                'totalMs': t,\r\n                'days': days,\r\n                'hours': hours,\r\n                'minutes': minutes,\r\n                'seconds': seconds,\r\n              };\r\n    }\r\n    // Когда число в таймере однозначное, подставляем вмереди нолик.\r\n    function getZero(num) {\r\n        if (num >= 0 && num < 10) {\r\n            return `0${num}`; //модифицируем, подставляем спереди нолик.\r\n        } else {\r\n            return num; //не модифицируем число.\r\n        }\r\n    }\r\n\r\n    // Устанавливаем таймер на страницу.\r\n    function setClock(selector, endtime) {\r\n        //Помещаем элементы со страницы\r\n        const timer = document.querySelector(selector), //получаем корневой ээлемент таймера .timer\r\n              days = timer.querySelector('#days'), // поучаем #days внутри .timer\r\n              hours = timer.querySelector('#hours'),\r\n              minutes = timer.querySelector('#minutes'),\r\n              seconds = timer.querySelector('#seconds');\r\n        updateClock(); //Указываем здесь, чтобы убрать мигание таймера при обновлении страницы. Нужно, когда const timeInterval = setInterval(updateClock, 1000); указана выше самой функции обновления.\r\n        //Обновляем таймер каждую секунду.\r\n        function updateClock() {\r\n            const t = getTimeRemaining(endtime); //Расчёт времени, который остался на текущую секунду. Это дедлай, который передаётся в setClock. Получаем объект с набором интересующих нас свойств.\r\n            //Помещаем расчётные величины на страницу.\r\n            days.innerHTML = getZero(t.days); //берём количество дней, котрое нужно отобразить на странице. getZero() - модифицирует число.\r\n            hours.innerHTML = getZero(t.hours);\r\n            minutes.innerHTML = getZero(t.minutes);\r\n            seconds.innerHTML = getZero(t.seconds);\r\n            //Когда функция запустится, она расчитает нужно время и на основании этих расчётов она бедут записывать на страницу все эти результаты.\r\n            //Запускаем функцию каждую секунду.\r\n            const timeInterval = setInterval(updateClock, 1000); //Запуск функции через определённый промежуток времени.\r\n            //Останавливаем таймер\r\n            if (t.totalMs <= 0) { //если разница между текущим временем и деадлайном меньше или равно 0,\r\n                clearInterval(timeInterval); //то перестаём обновлять таймер.\r\n            }\r\n        }\r\n        updateClock();\r\n    }\r\n    //вызываем все функции\r\n    setClock(id, deadline);\r\n}\r\n\r\nexport default timer;","'use strict';\n\nimport cacl from './modules/cacl';\nimport cards from './modules/cards';\nimport forms from './modules/forms';\nimport modal from './modules/modal';\nimport slider from './modules/slider';\nimport tabs from './modules/tabs';\nimport timer from './modules/timer';\nimport {openModal} from './modules/modal';\n\nwindow.addEventListener('DOMContentLoaded', () => {\n\n    //Вызываем модальное окно через промежуток времени.\n    const modalTimerId = setTimeout(() => openModal('.modal', modalTimerId), 30000);\n\n    cacl();\n    cards();\n    modal('[data-modal]', '.modal', modalTimerId);\n    forms('form', modalTimerId);\n    tabs('.tabheader__item', '.tabcontent', '.tabheader', 'tabheader__item_active');\n    timer('.timer', '2020-12-31');\n    slider({ //реструктуризация.\n        conteiner: '.offer__slide',\n        nextArrow: '.offer__slider-next',\n        prevArrow: '.offer__slider-prev',\n        slide: '.offer__slider',\n        totalCounter: '#total',\n        currentCounter: '#current',\n        wrapper: '.offer__slider-wrapper',\n        field: '.offer__slider-inner'\n    });\n});\n\n\n\n","//пишем функцию postData, которая обрабатывает запрос к серверу, fetch'ит.\r\n//Получаем ответ от сервера, например, что запостили успешно. После этого трансформирует ответ в JSON-формат.\r\nconst postData = async (url, data) => { // postData - отвечает за постинг данных на сервер. async - внутри функции будет асинхронный код, для async необходимо использовать парный оператор await, await ставим перед теми операциями, которые нужно дождаться. async и await всегда используются вместе.\r\n    let res = await fetch(url, { // fetch - запрос. Fetch API предоставляет интерфейс JavaScript для работы с запросами и ответами HTTP. Он также предоставляет глобальный метод fetch(), который позволяет легко и логично получать ресурсы по сети асинхронно. Подобная функциональность ранее достигалась с помощью XMLHttpRequest.\r\n    // await - сначала ждёт пока запрос будет отправлен на сервер и только когда получили ответ от сервера записываются данные в переменную res.\r\n        //Задаём настройки - метод и body (которое отправляем).\r\n        method: 'POST',\r\n        headers: { //Заголовки, какой контент мы отправляем.\r\n            'Content-Type': 'application/json'\r\n        },\r\n        body: data //данные формы.\r\n    }); \r\n    //Обрабатываем JSON-формат.\r\n    return await res.json(); //Обозначение объектов JavaScript (JSON - JavaScript Object Notation) - стандартный текстовый формат для представления структурированных данных на основе синтаксиса объекта JavaScript. Он обычно используется для передачи данных в веб-приложениях (например, отправка некоторых данных с сервера клиенту,таким образом чтобы это могло отображаться на веб-странице или наоборот).\r\n    // await - дожидаемся окончания работы промисса json() и только после этого он его возвращает из функции.\r\n};\r\n\r\nconst getResource = async (url) => { //Получаем данные с сервера.\r\n    let res = await fetch(url);\r\n    if (!res.ok) {\r\n        throw new Error(`Could not fetch ${url}, status: ${res.status}`);\r\n    }\r\n    return await res.json(); \r\n};\r\n\r\nexport {postData};\r\nexport {getResource};"],"sourceRoot":""}